/*
 * PUC-Rio
 * INF1715 Compiladores
 * Gabriel de Quadros Ligneul 1212560
 *
 * scanner.l
 */

%option nounput
%option noinput
%option noyywrap

%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "parser/parser.h"
#include "util/error.h"
#include "util/new.h"
#include "util/table.h"
#include "util/vector.h"

/* Necessary for fixing warning generated by -ansi flag */
int fileno(FILE* stream);

static int current_line = 1;
static table_t symbols = NULL;
static vector_t* strings = NULL;

/* Converts escape to an character */
static char convert_escape(char escape);

/* Removes the escapes from a literal string. */
static char* remove_escapes(char* in);

/* Adds a symbol to the symbol's pool. */
static char* add_symbol(char* symbol);
%}

cbegin      "/*"
cany        ([^*\n]|"*"+[^\*\/\n])*
cstar       "*"+$
cend        "*"+"/"

line        \n
space       [ \t]+

integer     [0-9]+
hexa        0[xX][0-9A-Fa-f]+
literal     '(\\.|.)'

exp         [Ee][+-]?[0-9]+
float1      [0-9]+{exp}
float2      [0-9]+\.[0-9]*{exp}?
float3      \.[0-9]+{exp}?
float       {float1}|{float2}|{float3}

string      \"(\\.|[^\n\\"])*\"

id          [a-zA-Z_][a-zA-Z0-9_]*
any	        . 

%start C 

%%

{cbegin}    {
                BEGIN C;
            }

<C>{cstar}  |
<C>{cany}   {
            }

<C>{cend}   {
                BEGIN 0;
            }

{line}      { 
                current_line++;
            }

{space}     {
            }

void        {
                yylval.int_ = current_line;
                return TK_VOID; 
            }

bool        {
                yylval.int_ = current_line;
                return TK_BOOL;
            }
            
char        {
                yylval.int_ = current_line;
                return TK_CHAR;
            }

int         {
                yylval.int_ = current_line;
                return TK_INT;
            }

float       {
                yylval.int_ = current_line;
                return TK_FLOAT;
            }

if          {
                yylval.int_ = current_line;
                return TK_IF;
            }

else        {
                yylval.int_ = current_line;
                return TK_ELSE;
            }

while       {
                yylval.int_ = current_line;
                return TK_WHILE;
            }

return      {
                yylval.int_ = current_line;
                return TK_RETURN;
            }

new         {
                yylval.int_ = current_line;
                return TK_NEW;
            }

delete      {
                yylval.int_ = current_line;
                return TK_DELETE;
            }

null        {
                yylval.int_ = current_line;
                return TK_NULL;
            }

true        {
                yylval.int_ = current_line;
                return TK_TRUE;
            }

false       {
                yylval.int_ = current_line;
                return TK_FALSE;
            }

"=="        {
                yylval.int_ = current_line;
                return TK_EQUALS;
            }

"!="        {
                yylval.int_ = current_line;
                return TK_NOT_EQUALS;
            }

"<="        {
                yylval.int_ = current_line;
                return TK_LESS_EQUALS;
            }

">="        {
                yylval.int_ = current_line;
                return TK_GREATER_EQUALS;
            }

"&&"        {
                yylval.int_ = current_line;
                return TK_AND;
            }

"||"        {
                yylval.int_ = current_line;
                return TK_OR;
            }

{integer}   {
                yylval.int_ = (int)strtol(yytext, 0, 10);
                return TK_KINT;
            }

{hexa}      {
                yylval.int_ = (int)strtol(yytext, 0, 16);
                return TK_KINT;
            }

{literal}   {
                yylval.int_ = yyleng == 4 ? convert_escape(yytext[2]) : yytext[1];
                return TK_KINT;
            }

{float}     {
                yylval.float_ = (float)strtod(yytext, NULL);
                return TK_KFLOAT;
            }

{string}    {
                size_t i = 0;
                char* literal = remove_escapes(yytext);
                yylval.string_ = add_symbol(literal); 
                free(literal);

                if (strings == NULL)
                    strings = vector_create();

                for (i = 0; i < vector_size(strings); ++i) {
                    char* curr = (char*)vector_get(strings, i);
                    if (curr == yylval.string_)
                        return TK_STRING;
                }
                vector_push(strings, yylval.string_);
                return TK_STRING;
            }

{id}        {
                yylval.identifier_.str = add_symbol(yytext);
                yylval.identifier_.line = current_line;
                return TK_ID;
            }

{any}       {
                yylval.int_ = current_line;
                return yytext[0];
            }

%%

int scanner_line()
{
    return current_line;
}

char* scanner_token()
{
    return &(yytext[0]);
}

vector_t* scanner_get_strings()
{
    return strings;
}

static char convert_escape(char escape)
{
    switch (escape) {
    case '\\':
    case '"':
        return escape;
    case 'n':
        return '\n';
    case 't':
        return '\t';
    default:
        errorl(current_line, "unexpected escape '\\%c' (%d)", escape, escape);
    }
    return 0;
}

static char* remove_escapes(char* in)
{
    size_t len = strlen(in) - 2;
    char* out = (char*)malloc(len + 1);
    int i = 0;
    in++;
    while (*in != '"') {
        char c = *in++;
        if (c == '\\')
            c = convert_escape(*in++);
        out[i++] = c;
    }
    out[i] = '\0';
    return out;
}

static void* sym_cpy(void* s)
{
    size_t size = strlen((char*)s) + 1;
    char* out = (char*)malloc(size);
    strcpy(out, (char*)s);
    return out;
}

static void* sym_dummy(void* s)
{
    return s;
}

static int sym_cmp(void* a, void* b)
{
    return strcmp((char*)a, (char*)b) < 0;
}

static char* add_symbol(char* symbol)
{
    if (!symbols)
        symbols = table_create(free, free, sym_cpy, sym_dummy, sym_cmp);
    struct table_pair pair = table_insert(symbols, symbol, NULL);
    return pair.key;
}

